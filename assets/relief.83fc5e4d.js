function v(r){return(t,...e)=>ae(r,t,e)}function K(r,t){return v(le(r,t).get)}const{apply:ae,construct:jr,defineProperty:Vr,get:zr,getOwnPropertyDescriptor:le,getPrototypeOf:yt,has:qr,ownKeys:Hr,set:Yr,setPrototypeOf:Xr}=Reflect,{iterator:tt,species:$r,toStringTag:Gt,for:Zr}=Symbol,ce=Object,{create:Ct,defineProperty:Jr,freeze:Qr,is:Wr}=ce,he=Array,fe=he.prototype,Mt=fe[tt],ue=v(Mt),Bt=ArrayBuffer;K(Bt.prototype,"byteLength");const Ut=typeof SharedArrayBuffer!="undefined"?SharedArrayBuffer:null;Ut&&K(Ut.prototype,"byteLength");const Lt=yt(Uint8Array);Lt.from;const D=Lt.prototype;D[tt];v(D.keys);v(D.values);v(D.entries);v(D.set);v(D.reverse);v(D.fill);v(D.copyWithin);v(D.sort);v(D.slice);v(D.subarray);K(D,"buffer");K(D,"byteOffset");K(D,"length");K(D,Gt);const j=Uint32Array,ge=Float32Array,Nt=yt([][tt]()),de=v(Nt.next),ye=v(function*(){}().next),pe=yt(Nt),me=DataView.prototype,xe=v(me.getUint16),kt=WeakMap,we=kt.prototype,be=v(we.get);function Se(r){if(r[tt]===Mt)return r;const t=ue(r);return Ct(null,{next:{value:function(){return de(t)}},[tt]:{value:function(){return this}}})}const Te=new kt;Ct(pe,{next:{value:function(){const t=be(Te,this);return ye(t)},writable:!0,configurable:!0},[Gt]:{value:"Array Iterator",configurable:!0}});const _t=new Bt(4),Ae=new ge(_t),Ie=new j(_t),F=new j(512),G=new j(512);for(let r=0;r<256;++r){const t=r-127;t<-27?(F[r]=0,F[r|256]=32768,G[r]=24,G[r|256]=24):t<-14?(F[r]=1024>>-t-14,F[r|256]=1024>>-t-14|32768,G[r]=-t-1,G[r|256]=-t-1):t<=15?(F[r]=t+15<<10,F[r|256]=t+15<<10|32768,G[r]=13,G[r|256]=13):t<128?(F[r]=31744,F[r|256]=64512,G[r]=24,G[r|256]=24):(F[r]=31744,F[r|256]=64512,G[r]=13,G[r|256]=13)}const at=new j(2048),U=new j(64),lt=new j(64);at[0]=0;for(let r=1;r<1024;++r){let t=r<<13,e=0;for(;(t&8388608)==0;)e-=8388608,t<<=1;t&=~8388608,e+=947912704,at[r]=t|e}for(let r=1024;r<2048;++r)at[r]=939524096+(r-1024<<13);U[0]=0;for(let r=1;r<31;++r)U[r]=r<<23;U[31]=1199570944;U[32]=2147483648;for(let r=33;r<63;++r)U[r]=2147483648+(r-32<<23);U[63]=3347054592;lt[0]=0;for(let r=1;r<64;++r)r===32?lt[r]=0:lt[r]=1024;function ve(r){const t=r>>10;return Ie[0]=at[lt[t]+(r&1023)]+U[t],Ae[0]}function Kt(r,t,...e){return ve(xe(r,t,...Se(e)))}function De(r,t,e){const s=e&&e.debug||!1;s&&console.log("getting "+t+" in "+r);const n=typeof r=="object"?r.outer:r,i=`${t}\\="([^"]*)"`;s&&console.log("pattern:",i);const a=new RegExp(i).exec(n);if(s&&console.log("match:",a),a)return a[1]}var jt=De;function Ee(r,t,e){const n=new RegExp(t).exec(r.slice(e));return n?e+n.index:-1}var Oe=Ee;const pt=Oe;function Pe(r,t,e){const s=e&&e.debug||!1,n=e&&e.startIndex||0;s&&console.log("starting findTagByName with",t," and ",e);const i=pt(r,`<${t}[ >]`,n);if(s&&console.log("start:",i),i===-1)return;const o=r.slice(i+t.length);let a=pt(o,"[ /]"+t+">",0);const c=a===-1;c&&(a=pt(o,"[ /]>",0));const l=i+t.length+a+1+(c?0:t.length)+1;if(s&&console.log("end:",l),l===-1)return;const h=r.slice(i,l);let f;return c?f=null:f=h.slice(h.indexOf(">")+1,h.lastIndexOf("<")),{inner:f,outer:h,start:i,end:l}}var Re=Pe;const Fe=Re;function Ge(r,t,e){const s=[],n=e&&e.debug||!1;let i=e&&e.startIndex||0,o;for(;o=Fe(r,t,{debug:n,startIndex:i});)i=o.end,s.push(o);return n&&console.log("findTagsByName found",s.length,"tags"),s}var Ce=Ge;const et={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},C={};for(const r in et)et.hasOwnProperty(r)&&(C[et[r]]=parseInt(r,10));const Me=[C.BitsPerSample,C.ExtraSamples,C.SampleFormat,C.StripByteCounts,C.StripOffsets,C.StripRowCounts,C.TileByteCounts,C.TileOffsets,C.SubIFDs],mt={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},x={};for(const r in mt)mt.hasOwnProperty(r)&&(x[mt[r]]=parseInt(r,10));const P={WhiteIsZero:0,BlackIsZero:1,RGB:2,Palette:3,TransparencyMask:4,CMYK:5,YCbCr:6,CIELab:8,ICCLab:9},Be={Unspecified:0,Assocalpha:1,Unassalpha:2},ts={Version:0,AddCompression:1},es={None:0,Deflate:1},ct={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"},Ue={};for(const r in ct)ct.hasOwnProperty(r)&&(Ue[ct[r]]=parseInt(r,10));function Le(r,t){const{width:e,height:s}=r,n=new Uint8Array(e*s*3);let i;for(let o=0,a=0;o<r.length;++o,a+=3)i=256-r[o]/t*256,n[a]=i,n[a+1]=i,n[a+2]=i;return n}function Ne(r,t){const{width:e,height:s}=r,n=new Uint8Array(e*s*3);let i;for(let o=0,a=0;o<r.length;++o,a+=3)i=r[o]/t*256,n[a]=i,n[a+1]=i,n[a+2]=i;return n}function ke(r,t){const{width:e,height:s}=r,n=new Uint8Array(e*s*3),i=t.length/3,o=t.length/3*2;for(let a=0,c=0;a<r.length;++a,c+=3){const l=r[a];n[c]=t[l]/65536*256,n[c+1]=t[l+i]/65536*256,n[c+2]=t[l+o]/65536*256}return n}function _e(r){const{width:t,height:e}=r,s=new Uint8Array(t*e*3);for(let n=0,i=0;n<r.length;n+=4,i+=3){const o=r[n],a=r[n+1],c=r[n+2],l=r[n+3];s[i]=255*((255-o)/256)*((255-l)/256),s[i+1]=255*((255-a)/256)*((255-l)/256),s[i+2]=255*((255-c)/256)*((255-l)/256)}return s}function Ke(r){const{width:t,height:e}=r,s=new Uint8ClampedArray(t*e*3);for(let n=0,i=0;n<r.length;n+=3,i+=3){const o=r[n],a=r[n+1],c=r[n+2];s[i]=o+1.402*(c-128),s[i+1]=o-.34414*(a-128)-.71414*(c-128),s[i+2]=o+1.772*(a-128)}return s}const je=.95047,Ve=1,ze=1.08883;function qe(r){const{width:t,height:e}=r,s=new Uint8Array(t*e*3);for(let n=0,i=0;n<r.length;n+=3,i+=3){const o=r[n+0],a=r[n+1]<<24>>24,c=r[n+2]<<24>>24;let l=(o+16)/116,h=a/500+l,f=l-c/200,y,u,g;h=je*(h*h*h>.008856?h*h*h:(h-16/116)/7.787),l=Ve*(l*l*l>.008856?l*l*l:(l-16/116)/7.787),f=ze*(f*f*f>.008856?f*f*f:(f-16/116)/7.787),y=h*3.2406+l*-1.5372+f*-.4986,u=h*-.9689+l*1.8758+f*.0415,g=h*.0557+l*-.204+f*1.057,y=y>.0031308?1.055*y**(1/2.4)-.055:12.92*y,u=u>.0031308?1.055*u**(1/2.4)-.055:12.92*u,g=g>.0031308?1.055*g**(1/2.4)-.055:12.92*g,s[i]=Math.max(0,Math.min(1,y))*255,s[i+1]=Math.max(0,Math.min(1,u))*255,s[i+2]=Math.max(0,Math.min(1,g))*255}return s}const Vt=new Map;function L(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>Vt.set(e,t))}async function He(r){const t=Vt.get(r.Compression);if(!t)throw new Error(`Unknown compression method identifier: ${r.Compression}`);const e=await t();return new e(r)}L([void 0,1],()=>import("./raw.f9f795b5.js").then(r=>r.default));L(5,()=>import("./lzw.af7f834f.js").then(r=>r.default));L(6,()=>{throw new Error("old style JPEG compression is not supported.")});L(7,()=>import("./jpeg.d77a600d.js").then(r=>r.default));L([8,32946],()=>import("./deflate.786b05f1.js").then(r=>r.default));L(32773,()=>import("./packbits.13c43dee.js").then(r=>r.default));L(34887,()=>import("./lerc.b944fd1d.js").then(r=>r.default));function ht(r,t,e,s=1){return new(Object.getPrototypeOf(r)).constructor(t*e*s)}function Ye(r,t,e,s,n){const i=t/s,o=e/n;return r.map(a=>{const c=ht(a,s,n);for(let l=0;l<n;++l){const h=Math.min(Math.round(o*l),e-1);for(let f=0;f<s;++f){const y=Math.min(Math.round(i*f),t-1),u=a[h*t+y];c[l*s+f]=u}}return c})}function V(r,t,e){return(1-e)*r+e*t}function Xe(r,t,e,s,n){const i=t/s,o=e/n;return r.map(a=>{const c=ht(a,s,n);for(let l=0;l<n;++l){const h=o*l,f=Math.floor(h),y=Math.min(Math.ceil(h),e-1);for(let u=0;u<s;++u){const g=i*u,d=g%1,p=Math.floor(g),b=Math.min(Math.ceil(g),t-1),m=a[f*t+p],S=a[f*t+b],T=a[y*t+p],A=a[y*t+b],E=V(V(m,S,d),V(T,A,d),h%1);c[l*s+u]=E}}return c})}function $e(r,t,e,s,n,i="nearest"){switch(i.toLowerCase()){case"nearest":return Ye(r,t,e,s,n);case"bilinear":case"linear":return Xe(r,t,e,s,n);default:throw new Error(`Unsupported resampling method: '${i}'`)}}function Ze(r,t,e,s,n,i){const o=t/s,a=e/n,c=ht(r,s,n,i);for(let l=0;l<n;++l){const h=Math.min(Math.round(a*l),e-1);for(let f=0;f<s;++f){const y=Math.min(Math.round(o*f),t-1);for(let u=0;u<i;++u){const g=r[h*t*i+y*i+u];c[l*s*i+f*i+u]=g}}}return c}function Je(r,t,e,s,n,i){const o=t/s,a=e/n,c=ht(r,s,n,i);for(let l=0;l<n;++l){const h=a*l,f=Math.floor(h),y=Math.min(Math.ceil(h),e-1);for(let u=0;u<s;++u){const g=o*u,d=g%1,p=Math.floor(g),b=Math.min(Math.ceil(g),t-1);for(let m=0;m<i;++m){const S=r[f*t*i+p*i+m],T=r[f*t*i+b*i+m],A=r[y*t*i+p*i+m],E=r[y*t*i+b*i+m],X=V(V(S,T,d),V(A,E,d),h%1);c[l*s*i+u*i+m]=X}}}return c}function Qe(r,t,e,s,n,i,o="nearest"){switch(o.toLowerCase()){case"nearest":return Ze(r,t,e,s,n,i);case"bilinear":case"linear":return Je(r,t,e,s,n,i);default:throw new Error(`Unsupported resampling method: '${o}'`)}}function We(r,t,e){let s=0;for(let n=t;n<e;++n)s+=r[n];return s}function xt(r,t,e){switch(r){case 1:if(t<=8)return new Uint8Array(e);if(t<=16)return new Uint16Array(e);if(t<=32)return new Uint32Array(e);break;case 2:if(t===8)return new Int8Array(e);if(t===16)return new Int16Array(e);if(t===32)return new Int32Array(e);break;case 3:switch(t){case 16:case 32:return new Float32Array(e);case 64:return new Float64Array(e)}break}throw Error("Unsupported data format/bitsPerSample")}function tr(r,t){return(r===1||r===2)&&t<=32&&t%8==0?!1:!(r===3&&(t===16||t===32||t===64))}function er(r,t,e,s,n,i,o){const a=new DataView(r),c=e===2?o*i:o*i*s,l=e===2?1:s,h=xt(t,n,c),f=parseInt("1".repeat(n),2);if(t===1){let y;e===1?y=s*n:y=n;let u=i*y;(u&7)!=0&&(u=u+7&~7);for(let g=0;g<o;++g){const d=g*u;for(let p=0;p<i;++p){const b=d+p*l*n;for(let m=0;m<l;++m){const S=b+m*n,T=(g*i+p)*l+m,A=Math.floor(S/8),E=S%8;if(E+n<=8)h[T]=a.getUint8(A)>>8-n-E&f;else if(E+n<=16)h[T]=a.getUint16(A)>>16-n-E&f;else if(E+n<=24){const X=a.getUint16(A)<<8|a.getUint8(A+2);h[T]=X>>24-n-E&f}else h[T]=a.getUint32(A)>>32-n-E&f}}}}return h.buffer}class rr{constructor(t,e,s,n,i,o){this.fileDirectory=t,this.geoKeys=e,this.dataView=s,this.littleEndian=n,this.tiles=i?{}:null,this.isTiled=!t.StripOffsets;const a=t.PlanarConfiguration;if(this.planarConfiguration=typeof a=="undefined"?1:a,this.planarConfiguration!==1&&this.planarConfiguration!==2)throw new Error("Invalid planar configuration.");this.source=o}getFileDirectory(){return this.fileDirectory}getGeoKeys(){return this.geoKeys}getWidth(){return this.fileDirectory.ImageWidth}getHeight(){return this.fileDirectory.ImageLength}getSamplesPerPixel(){return typeof this.fileDirectory.SamplesPerPixel!="undefined"?this.fileDirectory.SamplesPerPixel:1}getTileWidth(){return this.isTiled?this.fileDirectory.TileWidth:this.getWidth()}getTileHeight(){return this.isTiled?this.fileDirectory.TileLength:typeof this.fileDirectory.RowsPerStrip!="undefined"?Math.min(this.fileDirectory.RowsPerStrip,this.getHeight()):this.getHeight()}getBlockWidth(){return this.getTileWidth()}getBlockHeight(t){return this.isTiled||(t+1)*this.getTileHeight()<=this.getHeight()?this.getTileHeight():this.getHeight()-t*this.getTileHeight()}getBytesPerPixel(){let t=0;for(let e=0;e<this.fileDirectory.BitsPerSample.length;++e)t+=this.getSampleByteSize(e);return t}getSampleByteSize(t){if(t>=this.fileDirectory.BitsPerSample.length)throw new RangeError(`Sample index ${t} is out of range.`);return Math.ceil(this.fileDirectory.BitsPerSample[t]/8)}getReaderForSample(t){const e=this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[t]:1,s=this.fileDirectory.BitsPerSample[t];switch(e){case 1:if(s<=8)return DataView.prototype.getUint8;if(s<=16)return DataView.prototype.getUint16;if(s<=32)return DataView.prototype.getUint32;break;case 2:if(s<=8)return DataView.prototype.getInt8;if(s<=16)return DataView.prototype.getInt16;if(s<=32)return DataView.prototype.getInt32;break;case 3:switch(s){case 16:return function(n,i){return Kt(this,n,i)};case 32:return DataView.prototype.getFloat32;case 64:return DataView.prototype.getFloat64}break}throw Error("Unsupported data format/bitsPerSample")}getSampleFormat(t=0){return this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[t]:1}getBitsPerSample(t=0){return this.fileDirectory.BitsPerSample[t]}getArrayForSample(t,e){const s=this.getSampleFormat(t),n=this.getBitsPerSample(t);return xt(s,n,e)}async getTileOrStrip(t,e,s,n,i){const o=Math.ceil(this.getWidth()/this.getTileWidth()),a=Math.ceil(this.getHeight()/this.getTileHeight());let c;const{tiles:l}=this;this.planarConfiguration===1?c=e*o+t:this.planarConfiguration===2&&(c=s*o*a+e*o+t);let h,f;this.isTiled?(h=this.fileDirectory.TileOffsets[c],f=this.fileDirectory.TileByteCounts[c]):(h=this.fileDirectory.StripOffsets[c],f=this.fileDirectory.StripByteCounts[c]);const y=(await this.source.fetch([{offset:h,length:f}],i))[0];let u;return l===null||!l[c]?(u=(async()=>{let g=await n.decode(this.fileDirectory,y);const d=this.getSampleFormat(),p=this.getBitsPerSample();return tr(d,p)&&(g=er(g,d,this.planarConfiguration,this.getSamplesPerPixel(),p,this.getTileWidth(),this.getBlockHeight(e))),g})(),l!==null&&(l[c]=u)):u=l[c],{x:t,y:e,sample:s,data:await u}}async _readRaster(t,e,s,n,i,o,a,c,l){const h=this.getTileWidth(),f=this.getTileHeight(),y=this.getWidth(),u=this.getHeight(),g=Math.max(Math.floor(t[0]/h),0),d=Math.min(Math.ceil(t[2]/h),Math.ceil(y/h)),p=Math.max(Math.floor(t[1]/f),0),b=Math.min(Math.ceil(t[3]/f),Math.ceil(u/f)),m=t[2]-t[0];let S=this.getBytesPerPixel();const T=[],A=[];for(let O=0;O<e.length;++O)this.planarConfiguration===1?T.push(We(this.fileDirectory.BitsPerSample,0,e[O])/8):T.push(0),A.push(this.getReaderForSample(e[O]));const E=[],{littleEndian:X}=this;for(let O=p;O<b;++O)for(let gt=g;gt<d;++gt)for(let $=0;$<e.length;++$){const nt=$,Qt=e[$];this.planarConfiguration===2&&(S=this.getSampleByteSize($));const Rt=this.getTileOrStrip(gt,O,Qt,i,l);E.push(Rt),Rt.then(Z=>{const Wt=Z.data,te=new DataView(Wt),dt=this.getBlockHeight(Z.y),J=Z.y*f,it=Z.x*h,ee=J+dt,re=(Z.x+1)*h,se=A[nt],ne=Math.min(dt,dt-(ee-t[3]),u-J),ie=Math.min(h,h-(re-t[2]),y-it);for(let Q=Math.max(0,t[1]-J);Q<ne;++Q)for(let W=Math.max(0,t[0]-it);W<ie;++W){const oe=(Q*h+W)*S,Ft=se.call(te,oe+T[nt],X);let ot;n?(ot=(Q+J-t[1])*m*e.length+(W+it-t[0])*e.length+nt,s[ot]=Ft):(ot=(Q+J-t[1])*m+W+it-t[0],s[nt][ot]=Ft)}})}if(await Promise.all(E),o&&t[2]-t[0]!==o||a&&t[3]-t[1]!==a){let O;return n?O=Qe(s,t[2]-t[0],t[3]-t[1],o,a,e.length,c):O=$e(s,t[2]-t[0],t[3]-t[1],o,a,c),O.width=o,O.height=a,O}return s.width=o||t[2]-t[0],s.height=a||t[3]-t[1],s}async readRasters({window:t,samples:e=[],interleave:s,pool:n=null,width:i,height:o,resampleMethod:a,fillValue:c,signal:l}={}){const h=t||[0,0,this.getWidth(),this.getHeight()];if(h[0]>h[2]||h[1]>h[3])throw new Error("Invalid subsets");const f=h[2]-h[0],y=h[3]-h[1],u=f*y,g=this.getSamplesPerPixel();if(!e||!e.length)for(let m=0;m<g;++m)e.push(m);else for(let m=0;m<e.length;++m)if(e[m]>=g)return Promise.reject(new RangeError(`Invalid sample index '${e[m]}'.`));let d;if(s){const m=this.fileDirectory.SampleFormat?Math.max.apply(null,this.fileDirectory.SampleFormat):1,S=Math.max.apply(null,this.fileDirectory.BitsPerSample);d=xt(m,S,u*e.length),c&&d.fill(c)}else{d=[];for(let m=0;m<e.length;++m){const S=this.getArrayForSample(e[m],u);Array.isArray(c)&&m<c.length?S.fill(c[m]):c&&!Array.isArray(c)&&S.fill(c),d.push(S)}}const p=n||await He(this.fileDirectory);return await this._readRaster(h,e,d,s,p,i,o,a,l)}async readRGB({window:t,interleave:e=!0,pool:s=null,width:n,height:i,resampleMethod:o,enableAlpha:a=!1,signal:c}={}){const l=t||[0,0,this.getWidth(),this.getHeight()];if(l[0]>l[2]||l[1]>l[3])throw new Error("Invalid subsets");const h=this.fileDirectory.PhotometricInterpretation;if(h===P.RGB){let b=[0,1,2];if(this.fileDirectory.ExtraSamples!==Be.Unspecified&&a){b=[];for(let m=0;m<this.fileDirectory.BitsPerSample.length;m+=1)b.push(m)}return this.readRasters({window:t,interleave:e,samples:b,pool:s,width:n,height:i,resampleMethod:o,signal:c})}let f;switch(h){case P.WhiteIsZero:case P.BlackIsZero:case P.Palette:f=[0];break;case P.CMYK:f=[0,1,2,3];break;case P.YCbCr:case P.CIELab:f=[0,1,2];break;default:throw new Error("Invalid or unsupported photometric interpretation.")}const y={window:l,interleave:!0,samples:f,pool:s,width:n,height:i,resampleMethod:o,signal:c},{fileDirectory:u}=this,g=await this.readRasters(y),d=2**this.fileDirectory.BitsPerSample[0];let p;switch(h){case P.WhiteIsZero:p=Le(g,d);break;case P.BlackIsZero:p=Ne(g,d);break;case P.Palette:p=ke(g,u.ColorMap);break;case P.CMYK:p=_e(g);break;case P.YCbCr:p=Ke(g);break;case P.CIELab:p=qe(g);break;default:throw new Error("Unsupported photometric interpretation.")}if(!e){const b=new Uint8Array(p.length/3),m=new Uint8Array(p.length/3),S=new Uint8Array(p.length/3);for(let T=0,A=0;T<p.length;T+=3,++A)b[A]=p[T],m[A]=p[T+1],S[A]=p[T+2];p=[b,m,S]}return p.width=g.width,p.height=g.height,p}getTiePoints(){if(!this.fileDirectory.ModelTiepoint)return[];const t=[];for(let e=0;e<this.fileDirectory.ModelTiepoint.length;e+=6)t.push({i:this.fileDirectory.ModelTiepoint[e],j:this.fileDirectory.ModelTiepoint[e+1],k:this.fileDirectory.ModelTiepoint[e+2],x:this.fileDirectory.ModelTiepoint[e+3],y:this.fileDirectory.ModelTiepoint[e+4],z:this.fileDirectory.ModelTiepoint[e+5]});return t}getGDALMetadata(t=null){const e={};if(!this.fileDirectory.GDAL_METADATA)return null;const s=this.fileDirectory.GDAL_METADATA;let n=Ce(s,"Item");t!==null&&(n=n.filter(i=>Number(jt(i,"sample"))===t));for(let i=0;i<n.length;++i){const o=n[i];e[jt(o,"name")]=o.inner}return e}getGDALNoData(){if(!this.fileDirectory.GDAL_NODATA)return null;const t=this.fileDirectory.GDAL_NODATA;return Number(t.substring(0,t.length-1))}getOrigin(){const t=this.fileDirectory.ModelTiepoint,e=this.fileDirectory.ModelTransformation;if(t&&t.length===6)return[t[3],t[4],t[5]];if(e)return[e[3],e[7],e[11]];throw new Error("The image does not have an affine transformation.")}getResolution(t=null){const e=this.fileDirectory.ModelPixelScale,s=this.fileDirectory.ModelTransformation;if(e)return[e[0],-e[1],e[2]];if(s)return[s[0],s[5],s[10]];if(t){const[n,i,o]=t.getResolution();return[n*t.getWidth()/this.getWidth(),i*t.getHeight()/this.getHeight(),o*t.getWidth()/this.getWidth()]}throw new Error("The image does not have an affine transformation.")}pixelIsArea(){return this.geoKeys.GTRasterTypeGeoKey===1}getBoundingBox(){const t=this.getOrigin(),e=this.getResolution(),s=t[0],n=t[1],i=s+e[0]*this.getWidth(),o=n+e[1]*this.getHeight();return[Math.min(s,i),Math.min(n,o),Math.max(s,i),Math.max(n,o)]}}var sr=rr;class nr{constructor(t){this._dataView=new DataView(t)}get buffer(){return this._dataView.buffer}getUint64(t,e){const s=this.getUint32(t,e),n=this.getUint32(t+4,e);let i;if(e){if(i=s+2**32*n,!Number.isSafeInteger(i))throw new Error(`${i} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return i}if(i=2**32*s+n,!Number.isSafeInteger(i))throw new Error(`${i} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return i}getInt64(t,e){let s=0;const n=(this._dataView.getUint8(t+(e?7:0))&128)>0;let i=!0;for(let o=0;o<8;o++){let a=this._dataView.getUint8(t+(e?o:7-o));n&&(i?a!==0&&(a=~(a-1)&255,i=!1):a=~a&255),s+=a*256**o}return n&&(s=-s),s}getUint8(t,e){return this._dataView.getUint8(t,e)}getInt8(t,e){return this._dataView.getInt8(t,e)}getUint16(t,e){return this._dataView.getUint16(t,e)}getInt16(t,e){return this._dataView.getInt16(t,e)}getUint32(t,e){return this._dataView.getUint32(t,e)}getInt32(t,e){return this._dataView.getInt32(t,e)}getFloat16(t,e){return Kt(this._dataView,t,e)}getFloat32(t,e){return this._dataView.getFloat32(t,e)}getFloat64(t,e){return this._dataView.getFloat64(t,e)}}class ir{constructor(t,e,s,n){this._dataView=new DataView(t),this._sliceOffset=e,this._littleEndian=s,this._bigTiff=n}get sliceOffset(){return this._sliceOffset}get sliceTop(){return this._sliceOffset+this.buffer.byteLength}get littleEndian(){return this._littleEndian}get bigTiff(){return this._bigTiff}get buffer(){return this._dataView.buffer}covers(t,e){return this.sliceOffset<=t&&this.sliceTop>=t+e}readUint8(t){return this._dataView.getUint8(t-this._sliceOffset,this._littleEndian)}readInt8(t){return this._dataView.getInt8(t-this._sliceOffset,this._littleEndian)}readUint16(t){return this._dataView.getUint16(t-this._sliceOffset,this._littleEndian)}readInt16(t){return this._dataView.getInt16(t-this._sliceOffset,this._littleEndian)}readUint32(t){return this._dataView.getUint32(t-this._sliceOffset,this._littleEndian)}readInt32(t){return this._dataView.getInt32(t-this._sliceOffset,this._littleEndian)}readFloat32(t){return this._dataView.getFloat32(t-this._sliceOffset,this._littleEndian)}readFloat64(t){return this._dataView.getFloat64(t-this._sliceOffset,this._littleEndian)}readUint64(t){const e=this.readUint32(t),s=this.readUint32(t+4);let n;if(this._littleEndian){if(n=e+2**32*s,!Number.isSafeInteger(n))throw new Error(`${n} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return n}if(n=2**32*e+s,!Number.isSafeInteger(n))throw new Error(`${n} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return n}readInt64(t){let e=0;const s=(this._dataView.getUint8(t+(this._littleEndian?7:0))&128)>0;let n=!0;for(let i=0;i<8;i++){let o=this._dataView.getUint8(t+(this._littleEndian?i:7-i));s&&(n?o!==0&&(o=~(o-1)&255,n=!1):o=~o&255),e+=o*256**i}return s&&(e=-e),e}readOffset(t){return this._bigTiff?this.readUint64(t):this.readUint32(t)}}const zt=`\r
\r
`;function qt(r){if(typeof Object.fromEntries!="undefined")return Object.fromEntries(r);const t={};for(const[e,s]of r)t[e.toLowerCase()]=s;return t}function or(r){const t=r.split(`\r
`).map(e=>{const s=e.split(":").map(n=>n.trim());return s[0]=s[0].toLowerCase(),s});return qt(t)}function ar(r){const[t,...e]=r.split(";").map(n=>n.trim()),s=e.map(n=>n.split("="));return{type:t,params:qt(s)}}function wt(r){let t,e,s;return r&&([,t,e,s]=r.match(/bytes (\d+)-(\d+)\/(\d+)/),t=parseInt(t,10),e=parseInt(e,10),s=parseInt(s,10)),{start:t,end:e,total:s}}function lr(r,t){let e=null;const s=new TextDecoder("ascii"),n=[],i=`--${t}`,o=`${i}--`;for(let a=0;a<10;++a)s.decode(new Uint8Array(r,a,i.length))===i&&(e=a);if(e===null)throw new Error("Could not find initial boundary");for(;e<r.byteLength;){const a=s.decode(new Uint8Array(r,e,Math.min(i.length+1024,r.byteLength-e)));if(a.length===0||a.startsWith(o))break;if(!a.startsWith(i))throw new Error("Part does not start with boundary");const c=a.substr(i.length+2);if(c.length===0)break;const l=c.indexOf(zt),h=or(c.substr(0,l)),{start:f,end:y,total:u}=wt(h["content-range"]),g=e+i.length+l+zt.length,d=parseInt(y,10)+1-parseInt(f,10);n.push({headers:h,data:r.slice(g,g+d),offset:f,length:d,fileSize:u}),e=g+d+4}return n}class Ht{async fetch(t,e=void 0){return Promise.all(t.map(s=>this.fetchSlice(s,e)))}async fetchSlice(t){throw new Error(`fetching of slice ${t} not possible, not implemented`)}get fileSize(){return null}async close(){}}var cr=w;w.Node=N;w.create=w;function w(r){var t=this;if(t instanceof w||(t=new w),t.tail=null,t.head=null,t.length=0,r&&typeof r.forEach=="function")r.forEach(function(n){t.push(n)});else if(arguments.length>0)for(var e=0,s=arguments.length;e<s;e++)t.push(arguments[e]);return t}w.prototype.removeNode=function(r){if(r.list!==this)throw new Error("removing node which does not belong to this list");var t=r.next,e=r.prev;return t&&(t.prev=e),e&&(e.next=t),r===this.head&&(this.head=t),r===this.tail&&(this.tail=e),r.list.length--,r.next=null,r.prev=null,r.list=null,t};w.prototype.unshiftNode=function(r){if(r!==this.head){r.list&&r.list.removeNode(r);var t=this.head;r.list=this,r.next=t,t&&(t.prev=r),this.head=r,this.tail||(this.tail=r),this.length++}};w.prototype.pushNode=function(r){if(r!==this.tail){r.list&&r.list.removeNode(r);var t=this.tail;r.list=this,r.prev=t,t&&(t.next=r),this.tail=r,this.head||(this.head=r),this.length++}};w.prototype.push=function(){for(var r=0,t=arguments.length;r<t;r++)fr(this,arguments[r]);return this.length};w.prototype.unshift=function(){for(var r=0,t=arguments.length;r<t;r++)ur(this,arguments[r]);return this.length};w.prototype.pop=function(){if(!!this.tail){var r=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,r}};w.prototype.shift=function(){if(!!this.head){var r=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,r}};w.prototype.forEach=function(r,t){t=t||this;for(var e=this.head,s=0;e!==null;s++)r.call(t,e.value,s,this),e=e.next};w.prototype.forEachReverse=function(r,t){t=t||this;for(var e=this.tail,s=this.length-1;e!==null;s--)r.call(t,e.value,s,this),e=e.prev};w.prototype.get=function(r){for(var t=0,e=this.head;e!==null&&t<r;t++)e=e.next;if(t===r&&e!==null)return e.value};w.prototype.getReverse=function(r){for(var t=0,e=this.tail;e!==null&&t<r;t++)e=e.prev;if(t===r&&e!==null)return e.value};w.prototype.map=function(r,t){t=t||this;for(var e=new w,s=this.head;s!==null;)e.push(r.call(t,s.value,this)),s=s.next;return e};w.prototype.mapReverse=function(r,t){t=t||this;for(var e=new w,s=this.tail;s!==null;)e.push(r.call(t,s.value,this)),s=s.prev;return e};w.prototype.reduce=function(r,t){var e,s=this.head;if(arguments.length>1)e=t;else if(this.head)s=this.head.next,e=this.head.value;else throw new TypeError("Reduce of empty list with no initial value");for(var n=0;s!==null;n++)e=r(e,s.value,n),s=s.next;return e};w.prototype.reduceReverse=function(r,t){var e,s=this.tail;if(arguments.length>1)e=t;else if(this.tail)s=this.tail.prev,e=this.tail.value;else throw new TypeError("Reduce of empty list with no initial value");for(var n=this.length-1;s!==null;n--)e=r(e,s.value,n),s=s.prev;return e};w.prototype.toArray=function(){for(var r=new Array(this.length),t=0,e=this.head;e!==null;t++)r[t]=e.value,e=e.next;return r};w.prototype.toArrayReverse=function(){for(var r=new Array(this.length),t=0,e=this.tail;e!==null;t++)r[t]=e.value,e=e.prev;return r};w.prototype.slice=function(r,t){t=t||this.length,t<0&&(t+=this.length),r=r||0,r<0&&(r+=this.length);var e=new w;if(t<r||t<0)return e;r<0&&(r=0),t>this.length&&(t=this.length);for(var s=0,n=this.head;n!==null&&s<r;s++)n=n.next;for(;n!==null&&s<t;s++,n=n.next)e.push(n.value);return e};w.prototype.sliceReverse=function(r,t){t=t||this.length,t<0&&(t+=this.length),r=r||0,r<0&&(r+=this.length);var e=new w;if(t<r||t<0)return e;r<0&&(r=0),t>this.length&&(t=this.length);for(var s=this.length,n=this.tail;n!==null&&s>t;s--)n=n.prev;for(;n!==null&&s>r;s--,n=n.prev)e.push(n.value);return e};w.prototype.splice=function(r,t,...e){r>this.length&&(r=this.length-1),r<0&&(r=this.length+r);for(var s=0,n=this.head;n!==null&&s<r;s++)n=n.next;for(var i=[],s=0;n&&s<t;s++)i.push(n.value),n=this.removeNode(n);n===null&&(n=this.tail),n!==this.head&&n!==this.tail&&(n=n.prev);for(var s=0;s<e.length;s++)n=hr(this,n,e[s]);return i};w.prototype.reverse=function(){for(var r=this.head,t=this.tail,e=r;e!==null;e=e.prev){var s=e.prev;e.prev=e.next,e.next=s}return this.head=t,this.tail=r,this};function hr(r,t,e){var s=t===r.head?new N(e,null,t,r):new N(e,t,t.next,r);return s.next===null&&(r.tail=s),s.prev===null&&(r.head=s),r.length++,s}function fr(r,t){r.tail=new N(t,r.tail,null,r),r.head||(r.head=r.tail),r.length++}function ur(r,t){r.head=new N(t,null,r.head,r),r.tail||(r.tail=r.head),r.length++}function N(r,t,e,s){if(!(this instanceof N))return new N(r,t,e,s);this.list=s,this.value=r,t?(t.next=this,this.prev=t):this.prev=null,e?(e.prev=this,this.next=e):this.next=null}try{require("./iterator.js")(w)}catch{}const gr=cr,k=Symbol("max"),M=Symbol("length"),z=Symbol("lengthCalculator"),rt=Symbol("allowStale"),_=Symbol("maxAge"),B=Symbol("dispose"),Yt=Symbol("noDisposeOnSet"),I=Symbol("lruList"),R=Symbol("cache"),Xt=Symbol("updateAgeOnGet"),bt=()=>1;class dr{constructor(t){if(typeof t=="number"&&(t={max:t}),t||(t={}),t.max&&(typeof t.max!="number"||t.max<0))throw new TypeError("max must be a non-negative number");this[k]=t.max||1/0;const e=t.length||bt;if(this[z]=typeof e!="function"?bt:e,this[rt]=t.stale||!1,t.maxAge&&typeof t.maxAge!="number")throw new TypeError("maxAge must be a number");this[_]=t.maxAge||0,this[B]=t.dispose,this[Yt]=t.noDisposeOnSet||!1,this[Xt]=t.updateAgeOnGet||!1,this.reset()}set max(t){if(typeof t!="number"||t<0)throw new TypeError("max must be a non-negative number");this[k]=t||1/0,st(this)}get max(){return this[k]}set allowStale(t){this[rt]=!!t}get allowStale(){return this[rt]}set maxAge(t){if(typeof t!="number")throw new TypeError("maxAge must be a non-negative number");this[_]=t,st(this)}get maxAge(){return this[_]}set lengthCalculator(t){typeof t!="function"&&(t=bt),t!==this[z]&&(this[z]=t,this[M]=0,this[I].forEach(e=>{e.length=this[z](e.value,e.key),this[M]+=e.length})),st(this)}get lengthCalculator(){return this[z]}get length(){return this[M]}get itemCount(){return this[I].length}rforEach(t,e){e=e||this;for(let s=this[I].tail;s!==null;){const n=s.prev;$t(this,t,s,e),s=n}}forEach(t,e){e=e||this;for(let s=this[I].head;s!==null;){const n=s.next;$t(this,t,s,e),s=n}}keys(){return this[I].toArray().map(t=>t.key)}values(){return this[I].toArray().map(t=>t.value)}reset(){this[B]&&this[I]&&this[I].length&&this[I].forEach(t=>this[B](t.key,t.value)),this[R]=new Map,this[I]=new gr,this[M]=0}dump(){return this[I].map(t=>ft(this,t)?!1:{k:t.key,v:t.value,e:t.now+(t.maxAge||0)}).toArray().filter(t=>t)}dumpLru(){return this[I]}set(t,e,s){if(s=s||this[_],s&&typeof s!="number")throw new TypeError("maxAge must be a number");const n=s?Date.now():0,i=this[z](e,t);if(this[R].has(t)){if(i>this[k])return q(this,this[R].get(t)),!1;const c=this[R].get(t).value;return this[B]&&(this[Yt]||this[B](t,c.value)),c.now=n,c.maxAge=s,c.value=e,this[M]+=i-c.length,c.length=i,this.get(t),st(this),!0}const o=new yr(t,e,i,n,s);return o.length>this[k]?(this[B]&&this[B](t,e),!1):(this[M]+=o.length,this[I].unshift(o),this[R].set(t,this[I].head),st(this),!0)}has(t){if(!this[R].has(t))return!1;const e=this[R].get(t).value;return!ft(this,e)}get(t){return St(this,t,!0)}peek(t){return St(this,t,!1)}pop(){const t=this[I].tail;return t?(q(this,t),t.value):null}del(t){q(this,this[R].get(t))}load(t){this.reset();const e=Date.now();for(let s=t.length-1;s>=0;s--){const n=t[s],i=n.e||0;if(i===0)this.set(n.k,n.v);else{const o=i-e;o>0&&this.set(n.k,n.v,o)}}}prune(){this[R].forEach((t,e)=>St(this,e,!1))}}const St=(r,t,e)=>{const s=r[R].get(t);if(s){const n=s.value;if(ft(r,n)){if(q(r,s),!r[rt])return}else e&&(r[Xt]&&(s.value.now=Date.now()),r[I].unshiftNode(s));return n.value}},ft=(r,t)=>{if(!t||!t.maxAge&&!r[_])return!1;const e=Date.now()-t.now;return t.maxAge?e>t.maxAge:r[_]&&e>r[_]},st=r=>{if(r[M]>r[k])for(let t=r[I].tail;r[M]>r[k]&&t!==null;){const e=t.prev;q(r,t),t=e}},q=(r,t)=>{if(t){const e=t.value;r[B]&&r[B](e.key,e.value),r[M]-=e.length,r[R].delete(e.key),r[I].removeNode(t)}};class yr{constructor(t,e,s,n,i){this.key=t,this.value=e,this.length=s,this.now=n,this.maxAge=i||0}}const $t=(r,t,e,s)=>{let n=e.value;ft(r,n)&&(q(r,e),r[rt]||(n=void 0)),n&&t.call(s,n.value,n.key,r)};var pr=dr;async function mr(r){return new Promise(t=>setTimeout(t,r))}function Zt(r,t){const e=Array.isArray(r)?r:Array.from(r),s=Array.isArray(t)?t:Array.from(t);return e.map((n,i)=>[n,s[i]])}class H extends Error{constructor(t){super(t);Error.captureStackTrace&&Error.captureStackTrace(this,H),this.name="AbortError"}}class xr extends Error{constructor(t,e){super(e);this.errors=t,this.message=e,this.name="AggregateError"}}const wr=xr;class br{constructor(t,e,s=null){this.offset=t,this.length=e,this.data=s}get top(){return this.offset+this.length}}class Jt{constructor(t,e,s){this.offset=t,this.length=e,this.blockIds=s}}class Sr extends Ht{constructor(t,{blockSize:e=65536,cacheSize:s=100}={}){super();this.source=t,this.blockSize=e,this.blockCache=new pr({max:s}),this.blockRequests=new Map,this.blockIdsToFetch=new Set}get fileSize(){return this.source.fileSize}async fetch(t,e){const s=new Map,n=new Map,i=new Set;for(const{offset:l,length:h}of t){let f=l+h;const{fileSize:y}=this;y!==null&&(f=Math.min(f,y));const u=Math.floor(l/this.blockSize)*this.blockSize;for(let g=u;g<f;g+=this.blockSize){const d=Math.floor(g/this.blockSize);this.blockCache.has(d)?s.set(d,this.blockCache.get(d)):this.blockRequests.has(d)?n.set(d,this.blockRequests.get(d)):(this.blockIdsToFetch.has(d)||this.blockIdsToFetch.add(d),i.add(d))}}await mr(),this.fetchBlocks(e);for(const l of i){const h=this.blockRequests.get(l),f=this.blockCache.get(l);if(h)n.set(l,h);else if(f)s.set(l,f);else throw new Error(`Block ${l} is not in the block requests`)}let o=await Promise.allSettled(Array.from(n.values()));if(o.some(l=>l.status==="rejected")){const l=new Set;for(const[h,f]of Zt(n.keys(),o)){const{rejected:y,reason:u}=f;y&&u.name==="AbortError"&&u.signal!==e&&(this.blockIdsToFetch.add(h),l.add(h))}if(this.blockIdsToFetch.length>0){this.fetchBlocks(e);for(const h of l){const f=this.blockRequests.get(h);if(!f)throw new Error(`Block ${h} is not in the block requests`);n.set(h,f)}o=await Promise.allSettled(Array.from(n.values()))}}if(o.some(l=>l.status==="rejected"))throw e&&e.aborted?new H("Request was aborted"):new wr(o.filter(l=>l.status==="rejected").map(l=>l.reason),"Request failed");const a=o.map(l=>l.value),c=new Map(Zt(Array.from(n.keys()),a));for(const[l,h]of s)c.set(l,h);return this.readSliceData(t,c)}fetchBlocks(t){if(this.blockIdsToFetch.size>0){const e=this.groupBlocks(this.blockIdsToFetch),s=this.source.fetch(e,t);for(let n=0;n<e.length;++n){const i=e[n];for(const o of i.blockIds){const a=(async()=>{try{const c=(await s)[n],l=o*this.blockSize,h=l-c.offset,f=Math.min(h+this.blockSize,c.data.byteLength),y=c.data.slice(h,f),u=new br(l,y.byteLength,y);return this.blockCache.set(o,u),u}catch(c){throw c.name==="AbortError"&&(c.signal=t),c}finally{this.blockRequests.delete(o)}})();this.blockRequests.set(o,a)}}this.blockIdsToFetch.clear()}}groupBlocks(t){const e=Array.from(t).sort((o,a)=>o-a);if(e.length===0)return[];let s=[],n=null;const i=[];for(const o of e)n===null||n+1===o?(s.push(o),n=o):(i.push(new Jt(s[0]*this.blockSize,s.length*this.blockSize,s)),s=[o],n=o);return i.push(new Jt(s[0]*this.blockSize,s.length*this.blockSize,s)),i}readSliceData(t,e){return t.map(s=>{const n=s.offset+s.length,i=Math.floor(s.offset/this.blockSize),o=Math.floor((s.offset+s.length)/this.blockSize),a=new ArrayBuffer(s.length),c=new Uint8Array(a);for(let l=i;l<=o;++l){const h=e.get(l),f=h.offset-s.offset,y=h.top-n;let u=0,g=0,d;f<0?u=-f:f>0&&(g=f),y<0?d=h.length-u:d=n-h.offset-u;const p=new Uint8Array(h.data,u,d);c.set(p,g)}return a})}}class Tt{get ok(){return this.status>=200&&this.status<=299}get status(){throw new Error("not implemented")}getHeader(t){throw new Error("not implemented")}async getData(){throw new Error("not implemented")}}class At{constructor(t){this.url=t}async request({headers:t,credentials:e,signal:s}={}){throw new Error("request is not implemented")}}class Tr extends Tt{constructor(t){super();this.response=t}get status(){return this.response.status}getHeader(t){return this.response.headers.get(t)}async getData(){return this.response.arrayBuffer?await this.response.arrayBuffer():(await this.response.buffer()).buffer}}class Ar extends At{constructor(t,e){super(t);this.credentials=e}async request({headers:t,credentials:e,signal:s}={}){const n=await fetch(this.url,{headers:t,credentials:e,signal:s});return new Tr(n)}}class Ir extends Tt{constructor(t,e){super();this.xhr=t,this.data=e}get status(){return this.xhr.status}getHeader(t){return this.xhr.getResponseHeader(t)}async getData(){return this.data}}class vr extends At{constructRequest(t,e){return new Promise((s,n)=>{const i=new XMLHttpRequest;i.open("GET",this.url),i.responseType="arraybuffer";for(const[o,a]of Object.entries(t))i.setRequestHeader(o,a);i.onload=()=>{const o=i.response;s(new Ir(i,o))},i.onerror=n,i.onabort=()=>n(new H("Request aborted")),i.send(),e&&(e.aborted&&i.abort(),e.addEventListener("abort",()=>i.abort()))})}async request({headers:t,signal:e}={}){return await this.constructRequest(t,e)}}var It={};class Dr extends Tt{constructor(t,e){super();this.response=t,this.dataPromise=e}get status(){return this.response.statusCode}getHeader(t){return this.response.headers[t]}async getData(){return await this.dataPromise}}class Er extends At{constructor(t){super(t);this.parsedUrl=It.parse(this.url),this.httpApi=(this.parsedUrl.protocol==="http:",It)}constructRequest(t,e){return new Promise((s,n)=>{const i=this.httpApi.get({...this.parsedUrl,headers:t},o=>{const a=new Promise(c=>{const l=[];o.on("data",h=>{l.push(h)}),o.on("end",()=>{const h=Buffer.concat(l).buffer;c(h)}),o.on("error",n)});s(new Dr(o,a))});i.on("error",n),e&&(e.aborted&&i.destroy(new H("Request aborted")),e.addEventListener("abort",()=>i.destroy(new H("Request aborted"))))})}async request({headers:t,signal:e}={}){return await this.constructRequest(t,e)}}class vt extends Ht{constructor(t,e,s,n){super();this.client=t,this.headers=e,this.maxRanges=s,this.allowFullFile=n,this._fileSize=null}async fetch(t,e){return this.maxRanges>=t.length?this.fetchSlices(t,e):(this.maxRanges>0&&t.length>1,Promise.all(t.map(s=>this.fetchSlice(s,e))))}async fetchSlices(t,e){const s=await this.client.request({headers:{...this.headers,Range:`bytes=${t.map(({offset:n,length:i})=>`${n}-${n+i}`).join(",")}`},signal:e});if(s.ok)if(s.status===206){const{type:n,params:i}=ar(s.getHeader("content-type"));if(n==="multipart/byteranges"){const f=lr(await s.getData(),i.boundary);return this._fileSize=f[0].fileSize||null,f}const o=await s.getData(),{start:a,end:c,total:l}=wt(s.getHeader("content-range"));this._fileSize=l||null;const h=[{data:o,offset:a,length:c-a}];if(t.length>1){const f=await Promise.all(t.slice(1).map(y=>this.fetchSlice(y,e)));return h.concat(f)}return h}else{if(!this.allowFullFile)throw new Error("Server responded with full file");const n=await s.getData();return this._fileSize=n.byteLength,[{data:n,offset:0,length:n.byteLength}]}else throw new Error("Error fetching data.")}async fetchSlice(t,e){const{offset:s,length:n}=t,i=await this.client.request({headers:{...this.headers,Range:`bytes=${s}-${s+n}`},signal:e});if(i.ok)if(i.status===206){const o=await i.getData(),{total:a}=wt(i.getHeader("content-range"));return this._fileSize=a||null,{data:o,offset:s,length:n}}else{if(!this.allowFullFile)throw new Error("Server responded with full file");const o=await i.getData();return this._fileSize=o.byteLength,{data:o,offset:0,length:o.byteLength}}else throw new Error("Error fetching data.")}get fileSize(){return this._fileSize}}function Dt(r,{blockSize:t,cacheSize:e}){return t===null?r:new Sr(r,t,e)}function Or(r,{headers:t={},credentials:e,maxRanges:s=0,allowFullFile:n=!1,...i}={}){const o=new Ar(r,e),a=new vt(o,t,s,n);return Dt(a,i)}function Pr(r,{headers:t={},maxRanges:e=0,allowFullFile:s=!1,...n}={}){const i=new vr(r),o=new vt(i,t,e,s);return Dt(o,n)}function Rr(r,{headers:t={},maxRanges:e=0,allowFullFile:s=!1,...n}={}){const i=new Er(r),o=new vt(i,t,e,s);return Dt(o,n)}function Fr(r,{forceXHR:t=!1,...e}={}){return typeof fetch=="function"&&!t?Or(r,e):typeof XMLHttpRequest!="undefined"?Pr(r,e):Rr(r,e)}function Et(r){switch(r){case x.BYTE:case x.ASCII:case x.SBYTE:case x.UNDEFINED:return 1;case x.SHORT:case x.SSHORT:return 2;case x.LONG:case x.SLONG:case x.FLOAT:case x.IFD:return 4;case x.RATIONAL:case x.SRATIONAL:case x.DOUBLE:case x.LONG8:case x.SLONG8:case x.IFD8:return 8;default:throw new RangeError(`Invalid field type: ${r}`)}}function Gr(r){const t=r.GeoKeyDirectory;if(!t)return null;const e={};for(let s=4;s<=t[3]*4;s+=4){const n=ct[t[s]],i=t[s+1]?et[t[s+1]]:null,o=t[s+2],a=t[s+3];let c=null;if(!i)c=a;else{if(c=r[i],typeof c=="undefined"||c===null)throw new Error(`Could not get value of geoKey '${n}'.`);typeof c=="string"?c=c.substring(a,a+o-1):c.subarray&&(c=c.subarray(a,a+o),o===1&&(c=c[0]))}e[n]=c}return e}function Y(r,t,e,s){let n=null,i=null;const o=Et(t);switch(t){case x.BYTE:case x.ASCII:case x.UNDEFINED:n=new Uint8Array(e),i=r.readUint8;break;case x.SBYTE:n=new Int8Array(e),i=r.readInt8;break;case x.SHORT:n=new Uint16Array(e),i=r.readUint16;break;case x.SSHORT:n=new Int16Array(e),i=r.readInt16;break;case x.LONG:case x.IFD:n=new Uint32Array(e),i=r.readUint32;break;case x.SLONG:n=new Int32Array(e),i=r.readInt32;break;case x.LONG8:case x.IFD8:n=new Array(e),i=r.readUint64;break;case x.SLONG8:n=new Array(e),i=r.readInt64;break;case x.RATIONAL:n=new Uint32Array(e*2),i=r.readUint32;break;case x.SRATIONAL:n=new Int32Array(e*2),i=r.readInt32;break;case x.FLOAT:n=new Float32Array(e),i=r.readFloat32;break;case x.DOUBLE:n=new Float64Array(e),i=r.readFloat64;break;default:throw new RangeError(`Invalid field type: ${t}`)}if(t===x.RATIONAL||t===x.SRATIONAL)for(let a=0;a<e;a+=2)n[a]=i.call(r,s+a*o),n[a+1]=i.call(r,s+(a*o+4));else for(let a=0;a<e;++a)n[a]=i.call(r,s+a*o);return t===x.ASCII?new TextDecoder("utf-8").decode(n):n}class Cr{constructor(t,e,s){this.fileDirectory=t,this.geoKeyDirectory=e,this.nextIFDByteOffset=s}}class ut extends Error{constructor(t){super(`No image at index ${t}`);this.index=t}}class Mr{async readRasters(t={}){const{window:e,width:s,height:n}=t;let{resX:i,resY:o,bbox:a}=t;const c=await this.getImage();let l=c;const h=await this.getImageCount(),f=c.getBoundingBox();if(e&&a)throw new Error('Both "bbox" and "window" passed.');if(s||n){if(e){const[g,d]=c.getOrigin(),[p,b]=c.getResolution();a=[g+e[0]*p,d+e[1]*b,g+e[2]*p,d+e[3]*b]}const u=a||f;if(s){if(i)throw new Error("Both width and resX passed");i=(u[2]-u[0])/s}if(n){if(o)throw new Error("Both width and resY passed");o=(u[3]-u[1])/n}}if(i||o){const u=[];for(let g=0;g<h;++g){const d=await this.getImage(g),{SubfileType:p,NewSubfileType:b}=d.fileDirectory;(g===0||p===2||b&1)&&u.push(d)}u.sort((g,d)=>g.getWidth()-d.getWidth());for(let g=0;g<u.length;++g){const d=u[g],p=(f[2]-f[0])/d.getWidth(),b=(f[3]-f[1])/d.getHeight();if(l=d,i&&i>p||o&&o>b)break}}let y=e;if(a){const[u,g]=c.getOrigin(),[d,p]=l.getResolution(c);y=[Math.round((a[0]-u)/d),Math.round((a[1]-g)/p),Math.round((a[2]-u)/d),Math.round((a[3]-g)/p)],y=[Math.min(y[0],y[2]),Math.min(y[1],y[3]),Math.max(y[0],y[2]),Math.max(y[1],y[3])]}return l.readRasters({...t,window:y})}}class Ot extends Mr{constructor(t,e,s,n,i={}){super();this.source=t,this.littleEndian=e,this.bigTiff=s,this.firstIFDOffset=n,this.cache=i.cache||!1,this.ifdRequests=[],this.ghostValues=null}async getSlice(t,e){const s=this.bigTiff?4048:1024;return new ir((await this.source.fetch([{offset:t,length:typeof e!="undefined"?e:s}]))[0],t,this.littleEndian,this.bigTiff)}async parseFileDirectoryAt(t){const e=this.bigTiff?20:12,s=this.bigTiff?8:2;let n=await this.getSlice(t);const i=this.bigTiff?n.readUint64(t):n.readUint16(t),o=i*e+(this.bigTiff?16:6);n.covers(t,o)||(n=await this.getSlice(t,o));const a={};let c=t+(this.bigTiff?8:2);for(let f=0;f<i;c+=e,++f){const y=n.readUint16(c),u=n.readUint16(c+2),g=this.bigTiff?n.readUint64(c+4):n.readUint32(c+4);let d,p;const b=Et(u),m=c+(this.bigTiff?12:8);if(b*g<=(this.bigTiff?8:4))d=Y(n,u,g,m);else{const S=n.readOffset(m),T=Et(u)*g;if(n.covers(S,T))d=Y(n,u,g,S);else{const A=await this.getSlice(S,T);d=Y(A,u,g,S)}}g===1&&Me.indexOf(y)===-1&&!(u===x.RATIONAL||u===x.SRATIONAL)?p=d[0]:p=d,a[et[y]]=p}const l=Gr(a),h=n.readOffset(t+s+e*i);return new Cr(a,l,h)}async requestIFD(t){if(this.ifdRequests[t])return this.ifdRequests[t];if(t===0)return this.ifdRequests[t]=this.parseFileDirectoryAt(this.firstIFDOffset),this.ifdRequests[t];if(!this.ifdRequests[t-1])try{this.ifdRequests[t-1]=this.requestIFD(t-1)}catch(e){throw e instanceof ut?new ut(t):e}return this.ifdRequests[t]=(async()=>{const e=await this.ifdRequests[t-1];if(e.nextIFDByteOffset===0)throw new ut(t);return this.parseFileDirectoryAt(e.nextIFDByteOffset)})(),this.ifdRequests[t]}async getImage(t=0){const e=await this.requestIFD(t);return new sr(e.fileDirectory,e.geoKeyDirectory,this.dataView,this.littleEndian,this.cache,this.source)}async getImageCount(){let t=0,e=!0;for(;e;)try{await this.requestIFD(t),++t}catch(s){if(s instanceof ut)e=!1;else throw s}return t}async getGhostValues(){const t=this.bigTiff?16:8;if(this.ghostValues)return this.ghostValues;const e="GDAL_STRUCTURAL_METADATA_SIZE=",s=e.length+100;let n=await this.getSlice(t,s);if(e===Y(n,x.ASCII,e.length,t)){const o=Y(n,x.ASCII,s,t).split(`
`)[0],a=Number(o.split("=")[1].split(" ")[0])+o.length;a>s&&(n=await this.getSlice(t,a));const c=Y(n,x.ASCII,a,t);this.ghostValues={},c.split(`
`).filter(l=>l.length>0).map(l=>l.split("=")).forEach(([l,h])=>{this.ghostValues[l]=h})}return this.ghostValues}static async fromSource(t,e,s){const n=(await t.fetch([{offset:0,length:1024}],s))[0],i=new nr(n),o=i.getUint16(0,0);let a;if(o===18761)a=!0;else if(o===19789)a=!1;else throw new TypeError("Invalid byte order value.");const c=i.getUint16(2,a);let l;if(c===42)l=!1;else if(c===43){if(l=!0,i.getUint16(4,a)!==8)throw new Error("Unsupported offset byte-size.")}else throw new TypeError("Invalid magic number.");const h=l?i.getUint64(8,a):i.getUint32(4,a);return new Ot(t,a,l,h,e)}close(){return typeof this.source.close=="function"?this.source.close():!1}}async function Br(r,t={},e){return Ot.fromSource(Fr(r,t),e)}var Ur="./assets/z0.2330351f.tif",Lr="./assets/z1.6ed4d157.tif",Nr="./assets/z2.f292a7df.tif";async function Pt(r){return await(await(await Br(r)).getImage()).readRasters()}const kr=await Pt(Ur),_r=await Pt(Lr),Kr=await Pt(Nr);var rs=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",r110m:kr,r50m:_r,r10m:Kr});export{ts as L,es as a,rs as r};
